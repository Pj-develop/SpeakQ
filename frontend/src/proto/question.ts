// @generated by protobuf-ts 2.9.4 with parameter long_type_string
// @generated from protobuf file "question.proto" (package "question", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message question.QuestionRequest
 */
export interface QuestionRequest {
    /**
     * @generated from protobuf field: string query = 1;
     */
    query: string;
    /**
     * @generated from protobuf field: int32 limit = 2;
     */
    limit: number;
    /**
     * @generated from protobuf field: int32 page = 3;
     */
    page: number;
    /**
     * @generated from protobuf field: string type = 4;
     */
    type: string;
}
/**
 * @generated from protobuf message question.QuestionResponse
 */
export interface QuestionResponse {
    /**
     * @generated from protobuf field: repeated question.Question questions = 1;
     */
    questions: Question[];
    /**
     * @generated from protobuf field: int32 count = 2;
     */
    count: number;
}
/**
 * @generated from protobuf message question.Question
 */
export interface Question {
    _id: any;
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * @generated from protobuf field: repeated question.Block blocks = 3;
     */
    blocks: Block[];
    /**
     * @generated from protobuf field: string siblingId = 4;
     */
    siblingId: string;
    /**
     * @generated from protobuf field: string solution = 5;
     */
    solution: string;
    /**
     * @generated from protobuf field: string title = 6;
     */
    title: string;
    /**
     * @generated from protobuf field: string anagramType = 7;
     */
    anagramType: string;
    /**
     * @generated from protobuf field: repeated question.Option options = 8;
     */
    options: Option[];
}
/**
 * @generated from protobuf message question.Option
 */
export interface Option {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string;
    /**
     * @generated from protobuf field: bool isCorrect = 2;
     */
    isCorrect: boolean;
}
/**
 * @generated from protobuf message question.Block
 */
export interface Block {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string;
    /**
     * @generated from protobuf field: bool showInOption = 2;
     */
    showInOption: boolean;
    /**
     * @generated from protobuf field: bool isAnswer = 3;
     */
    isAnswer: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class QuestionRequest$Type extends MessageType<QuestionRequest> {
    constructor() {
        super("question.QuestionRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuestionRequest>): QuestionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        message.limit = 0;
        message.page = 0;
        message.type = "";
        if (value !== undefined)
            reflectionMergePartial<QuestionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestionRequest): QuestionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                case /* int32 limit */ 2:
                    message.limit = reader.int32();
                    break;
                case /* int32 page */ 3:
                    message.page = reader.int32();
                    break;
                case /* string type */ 4:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        /* int32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).int32(message.limit);
        /* int32 page = 3; */
        if (message.page !== 0)
            writer.tag(3, WireType.Varint).int32(message.page);
        /* string type = 4; */
        if (message.type !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message question.QuestionRequest
 */
export const QuestionRequest = new QuestionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuestionResponse$Type extends MessageType<QuestionResponse> {
    constructor() {
        super("question.QuestionResponse", [
            { no: 1, name: "questions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Question },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QuestionResponse>): QuestionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.questions = [];
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<QuestionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuestionResponse): QuestionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated question.Question questions */ 1:
                    message.questions.push(Question.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuestionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated question.Question questions = 1; */
        for (let i = 0; i < message.questions.length; i++)
            Question.internalBinaryWrite(message.questions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message question.QuestionResponse
 */
export const QuestionResponse = new QuestionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Question$Type extends MessageType<Question> {
    constructor() {
        super("question.Question", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "blocks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block },
            { no: 4, name: "siblingId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "solution", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "anagramType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Option }
        ]);
    }
    create(value?: PartialMessage<Question>): Question {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.type = "";
        message.blocks = [];
        message.siblingId = "";
        message.solution = "";
        message.title = "";
        message.anagramType = "";
        message.options = [];
        if (value !== undefined)
            reflectionMergePartial<Question>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Question): Question {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* repeated question.Block blocks */ 3:
                    message.blocks.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string siblingId */ 4:
                    message.siblingId = reader.string();
                    break;
                case /* string solution */ 5:
                    message.solution = reader.string();
                    break;
                case /* string title */ 6:
                    message.title = reader.string();
                    break;
                case /* string anagramType */ 7:
                    message.anagramType = reader.string();
                    break;
                case /* repeated question.Option options */ 8:
                    message.options.push(Option.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Question, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* repeated question.Block blocks = 3; */
        for (let i = 0; i < message.blocks.length; i++)
            Block.internalBinaryWrite(message.blocks[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string siblingId = 4; */
        if (message.siblingId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.siblingId);
        /* string solution = 5; */
        if (message.solution !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.solution);
        /* string title = 6; */
        if (message.title !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.title);
        /* string anagramType = 7; */
        if (message.anagramType !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.anagramType);
        /* repeated question.Option options = 8; */
        for (let i = 0; i < message.options.length; i++)
            Option.internalBinaryWrite(message.options[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message question.Question
 */
export const Question = new Question$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Option$Type extends MessageType<Option> {
    constructor() {
        super("question.Option", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isCorrect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Option>): Option {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.isCorrect = false;
        if (value !== undefined)
            reflectionMergePartial<Option>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Option): Option {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* bool isCorrect */ 2:
                    message.isCorrect = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Option, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* bool isCorrect = 2; */
        if (message.isCorrect !== false)
            writer.tag(2, WireType.Varint).bool(message.isCorrect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message question.Option
 */
export const Option = new Option$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Block$Type extends MessageType<Block> {
    constructor() {
        super("question.Block", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "showInOption", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "isAnswer", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Block>): Block {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.showInOption = false;
        message.isAnswer = false;
        if (value !== undefined)
            reflectionMergePartial<Block>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Block): Block {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* bool showInOption */ 2:
                    message.showInOption = reader.bool();
                    break;
                case /* bool isAnswer */ 3:
                    message.isAnswer = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Block, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* bool showInOption = 2; */
        if (message.showInOption !== false)
            writer.tag(2, WireType.Varint).bool(message.showInOption);
        /* bool isAnswer = 3; */
        if (message.isAnswer !== false)
            writer.tag(3, WireType.Varint).bool(message.isAnswer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message question.Block
 */
export const Block = new Block$Type();
/**
 * @generated ServiceType for protobuf service question.QuestionService
 */
export const QuestionService = new ServiceType("question.QuestionService", [
    { name: "GetQuestions", options: {}, I: QuestionRequest, O: QuestionResponse }
]);
